#!/usr/bin/env bash
# Hostkit (single-file build) — generated by tools/mkdist.sh
set -euo pipefail

##### === Configurable variables === #####
NEW_USER="${NEW_USER:-devops}"
NEW_USER_PASSWORD="${NEW_USER_PASSWORD:-}"
NEW_USER_SUDO_NOPASSWD="${NEW_USER_SUDO_NOPASSWD:-false}"

SSH_PORT="${SSH_PORT:-22}"
SSH_PUBKEY="${SSH_PUBKEY:-}"
ALLOW_PASSWORD_SSH="${ALLOW_PASSWORD_SSH:-false}"   # "true"/"false" -> mapped to yes/no

ALLOW_HTTP="${ALLOW_HTTP:-true}"
ALLOW_HTTPS="${ALLOW_HTTPS:-true}"
EXTRA_TCP_PORTS="${EXTRA_TCP_PORTS:-}"              # e.g. "5432,9100"

TIMEZONE="${TIMEZONE:-UTC}"
LIMIT_NOFILE="${LIMIT_NOFILE:-1048576}"
JOURNALD_MAXUSE="${JOURNALD_MAXUSE:-200M}"
ENVIRONMENT="${ENV:-prod}"

SUDO_SECURE_PATH="${SUDO_SECURE_PATH:-/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin}"
SUDO_LOGFILE="${SUDO_LOGFILE:-/var/log/sudo.log}"
SUDO_TIMESTAMP_TIMEOUT="${SUDO_TIMESTAMP_TIMEOUT:-15}"
##########################################

# === module: log.sh ===
info(){ echo "[INFO] $*"; }
warn(){ echo "[WARN] $*" >&2; }
die(){ echo "[ERROR] $*" >&2; exit 1; }
# === module: detect.sh ===

assert_root(){ [[ $EUID -eq 0 ]] || die "Run as root"; }

check_debian12() {
  if ! grep -qi "debian" /etc/os-release; then
    warn "This script targets Debian. Continue at your own risk."
  fi
  if ! grep -qi "bookworm" /etc/os-release; then
    warn "Not Debian 12 (bookworm). Proceeding anyway."
  fi
}

preflight_guard() {
  # If SSH public key provided -> OK
  if [[ -n "${SSH_PUBKEY//[[:space:]]/}" ]]; then
    echo "[INFO] Preflight: SSH public key provided -> OK"
    return
  fi

  # No public key -> require both password auth enabled AND a non-empty user password
  if [[ "${ALLOW_PASSWORD_SSH}" != "true" || -z "${NEW_USER_PASSWORD}" ]]; then
    echo "[ERROR] Unsafe configuration detected!"
    echo "        - No SSH public key provided."
    echo "        - Root SSH login is disabled by design."
    echo "        - NEW_USER_PASSWORD is empty OR password login disabled."
    echo
    echo "This would lock you out of the server."
    echo
    echo "✅ Correct usage examples:"
    echo "  # Option 1: provide one or more public keys (recommended)"
    echo "  SSH_PUBKEY=$'ssh-ed25519 AAAA... user1@host\nssh-rsa BBBB... user2@laptop' \\"
    echo "    bash dist/hostkit-deb12-init.sh"
    echo
    echo "  # Option 2: allow password login with a strong password"
    echo "  ALLOW_PASSWORD_SSH=true NEW_USER_PASSWORD='StrongPass#2025' \\"
    echo "    bash dist/hostkit-deb12-init.sh"
    echo
    exit 1
  fi

  echo "[INFO] Preflight: no public key, but password login enabled and NEW_USER_PASSWORD set -> OK"
}

# === module: apt.sh ===

install_base_packages() {
  export DEBIAN_FRONTEND=noninteractive
  info "apt: updating & upgrading"
  apt-get update -y
  apt-get dist-upgrade -y

  info "apt: installing base/security packages"

  apt-get install -y --no-install-recommends \
    sudo iptables iptables-persistent fail2ban chrony \
    unattended-upgrades apt-config-auto-update ca-certificates gnupg \
    lsb-release software-properties-common openssh-server needrestart

  info "apt: installing common utilities"
  apt-get install -y --no-install-recommends \
    vim nano less htop tmux screen \
    curl wget rsync git unzip zip tar jq \
    net-tools iproute2 dnsutils \
    build-essential pkg-config make cmake \
    python3 python3-pip \
    man-db bash-completion tree \
    strace
}

# === module: time.sh ===

setup_timezone_ntp() {
  info "time: timezone=$TIMEZONE, enabling chrony"
  timedatectl set-timezone "$TIMEZONE" || true
  systemctl enable --now chrony || true
}

# === module: user.sh ===
echo "[WARN] module missing: user.sh" >&2

# === module: sshd.sh ===
# SSH daemon hardening

setup_sshd_security() {
  local cfg="/etc/ssh/sshd_config"
  [[ -f ${cfg}.orig ]] || cp -a "$cfg" "${cfg}.orig"

  # map true/false -> yes/no
  local pass_auth="no"
  [[ "${ALLOW_PASSWORD_SSH}" == "true" ]] && pass_auth="yes"

  sed -ri 's/^#?PermitRootLogin.*/PermitRootLogin no/' "$cfg"
  sed -ri "s/^#?PasswordAuthentication.*/PasswordAuthentication ${pass_auth}/" "$cfg"
  sed -ri 's/^#?ChallengeResponseAuthentication.*/ChallengeResponseAuthentication no/' "$cfg"
  sed -ri 's/^#?UsePAM.*/UsePAM yes/' "$cfg"
  sed -ri 's/^#?X11Forwarding.*/X11Forwarding no/' "$cfg"
  sed -ri 's/^#?PermitEmptyPasswords.*/PermitEmptyPasswords no/' "$cfg"

  if grep -q '^#\?PubkeyAuthentication' "$cfg"; then
    sed -ri 's/^#?PubkeyAuthentication.*/PubkeyAuthentication yes/' "$cfg"
  else
    echo "PubkeyAuthentication yes" >>"$cfg"
  fi

  if ! grep -q "^AllowUsers" "$cfg"; then
    echo "AllowUsers ${NEW_USER}" >>"$cfg"
  else
    sed -ri "s/^AllowUsers.*/AllowUsers ${NEW_USER}/" "$cfg"
  fi

  if ! grep -q "^Port ${SSH_PORT}\b" "$cfg"; then
    if grep -q "^Port " "$cfg"; then
      sed -ri "s/^Port .*/Port ${SSH_PORT}/" "$cfg"
    else
      echo "Port ${SSH_PORT}" >>"$cfg"
    fi
  fi
}

reload_sshd() {
  systemctl reload ssh || systemctl restart ssh
}

# === module: unattended.sh ===
# Unattended upgrades (security)

setup_unattended_upgrades() {
  dpkg-reconfigure -fnoninteractive unattended-upgrades || true
  cat >/etc/apt/apt.conf.d/20auto-upgrades <<'EOF'
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
EOF
  systemctl enable --now unattended-upgrades || true
}

# === module: fail2ban.sh ===
# Fail2Ban baseline

setup_fail2ban() {
  systemctl enable --now fail2ban || true
  local jail="/etc/fail2ban/jail.local"
  if [[ ! -f "$jail" ]]; then
    cat >"$jail" <<EOF
[DEFAULT]
bantime = 1h
findtime = 10m
maxretry = 5
ignoreip = 127.0.0.1/8 ::1

[sshd]
enabled = true
port = ${SSH_PORT}
logpath = %(sshd_log)s
backend = systemd
EOF
    [[ "$ENVIRONMENT" != "prod" ]] && sed -ri 's/^bantime = .*/bantime = 10m/' "$jail"
  fi
  systemctl restart fail2ban || true
}

# === module: sysctl.sh ===
# Sysctl (network) tuning

sysctl_network_tuning() {
  local f=/etc/sysctl.d/99-tcp-tuning.conf
  cat >"$f" <<'EOF'
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
net.core.somaxconn = 4096
net.core.netdev_max_backlog = 16384
net.ipv4.tcp_max_syn_backlog = 4096
net.ipv4.ip_local_port_range = 10240 65535
net.ipv4.tcp_rmem = 4096 87380 33554432
net.ipv4.tcp_wmem = 4096 65536 33554432
net.ipv4.tcp_fin_timeout = 15
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 5
net.ipv4.tcp_fastopen = 3
EOF
  sysctl --system >/dev/null
}

# === module: limits.sh ===

set_limits() {
  ulimit -n ${LIMIT_NOFILE}

  # clamp to kernel maximum to avoid invalid settings
  local nr_open
  nr_open=$(cat /proc/sys/fs/nr_open 2>/dev/null || echo 1048576)
  if (( LIMIT_NOFILE > nr_open )); then
    warn "LIMIT_NOFILE(${LIMIT_NOFILE}) > fs.nr_open(${nr_open}); clamping to ${nr_open}"
    LIMIT_NOFILE="${nr_open}"
  fi

  # 1) PAM limits: affects new login sessions (sshd/tty)
  local lf=/etc/security/limits.d/90-nofile.conf
  cat >"$lf" <<EOF
* soft nofile ${LIMIT_NOFILE}
* hard nofile ${LIMIT_NOFILE}
root soft nofile ${LIMIT_NOFILE}
root hard nofile ${LIMIT_NOFILE}
EOF

  # 2) systemd default limits: affects systemd-managed services after restart
  #    (use a drop-in so we don't overwrite vendor file)
  local sysd_dir=/etc/systemd/system.conf.d
  mkdir -p "$sysd_dir"
  cat >"${sysd_dir}/90-nofile.conf" <<EOF
[Manager]
DefaultLimitNOFILE=${LIMIT_NOFILE}
EOF

  # apply systemd manager config without reboot
  systemctl daemon-reexec || true

  # 3) convenience for interactive shells: set soft limit on login
  #    (doesn't override PAM hard limit; new shells pick it up)
  cat >/etc/profile.d/90-nofile.sh <<EOF
# Set soft nofile for interactive shells; hard limit is defined by PAM limits.d
# This file is generated by hostkit.
if [ "\$-" != "\${-#*i}" ]; then
  # interactive shell
  ulimit -n ${LIMIT_NOFILE} 2>/dev/null || true
fi
EOF
  chmod 0644 /etc/profile.d/90-nofile.sh

  info "limits: nofile set to ${LIMIT_NOFILE} (PAM + systemd default). New logins/services will see it."
  info "limits: current shell won't change; re-login for interactive shells, restart services to apply."
}
# === module: journald.sh ===
echo "[WARN] module missing: journald.sh" >&2

# === module: firewall_iptables.sh ===
# iptables (IPv4 + IPv6) with persistence

firewall_iptables_apply() {
  info "Applying iptables rules (IPv4)..."
  iptables -F
  iptables -X
  iptables -P INPUT DROP
  iptables -P FORWARD DROP
  iptables -P OUTPUT ACCEPT

  iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
  iptables -A INPUT -i lo -j ACCEPT
  iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT

  # SSH with light rate-limit
  if [[ "${SSH_PORT}" == "22" ]]; then
    # only 22 with rate-limit
    iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW \
             -m hashlimit --hashlimit-name ssh --hashlimit 10/min --hashlimit-burst 20 --hashlimit-mode srcip \
             -j ACCEPT
  else
    # new SSH port with rate-limit
    iptables -A INPUT -p tcp --dport "${SSH_PORT}" -m conntrack --ctstate NEW \
             -m hashlimit --hashlimit-name ssh --hashlimit 10/min --hashlimit-burst 20 --hashlimit-mode srcip \
             -j ACCEPT
    # keep 22 with rate-limit
    iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT
  fi


  [[ "${ALLOW_HTTP}" == "true"  ]] && iptables -A INPUT -p tcp --dport 80  -j ACCEPT
  [[ "${ALLOW_HTTPS}" == "true" ]] && iptables -A INPUT -p tcp --dport 443 -j ACCEPT

  if [[ -n "${EXTRA_TCP_PORTS}" ]]; then
    IFS=',' read -ra ports <<< "$EXTRA_TCP_PORTS"
    for p in "${ports[@]}"; do
      iptables -A INPUT -p tcp --dport "$p" -j ACCEPT
    done
  fi

  iptables -A INPUT -j DROP

  info "Applying ip6tables rules (IPv6)..."
  ip6tables -F
  ip6tables -X
  ip6tables -P INPUT DROP
  ip6tables -P FORWARD DROP
  ip6tables -P OUTPUT ACCEPT

  ip6tables -A INPUT -m conntrack --ctstate INVALID -j DROP
  ip6tables -A INPUT -i lo -j ACCEPT
  ip6tables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ip6tables -A INPUT -p ipv6-icmp -j ACCEPT

  # SSH with light rate-limit
  if [[ "${SSH_PORT}" == "22" ]]; then
    ip6tables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW \
              -m hashlimit --hashlimit-name ssh6 --hashlimit 10/min --hashlimit-burst 20 --hashlimit-mode srcip \
              -j ACCEPT
  else
    ip6tables -A INPUT -p tcp --dport "${SSH_PORT}" -m conntrack --ctstate NEW \
              -m hashlimit --hashlimit-name ssh6 --hashlimit 10/min --hashlimit-burst 20 --hashlimit-mode srcip \
              -j ACCEPT
    ip6tables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT
  fi

  [[ "${ALLOW_HTTP}" == "true"  ]] && ip6tables -A INPUT -p tcp --dport 80  -j ACCEPT
  [[ "${ALLOW_HTTPS}" == "true" ]] && ip6tables -A INPUT -p tcp --dport 443 -j ACCEPT

  if [[ -n "${EXTRA_TCP_PORTS}" ]]; then
    IFS=',' read -ra ports6 <<< "$EXTRA_TCP_PORTS"
    for p in "${ports6[@]}"; do
      ip6tables -A INPUT -p tcp --dport "$p" -j ACCEPT
    done
  fi

  ip6tables -A INPUT -j DROP

  info "Persisting firewall rules..."
  netfilter-persistent save || true
  systemctl enable netfilter-persistent || true
  systemctl start netfilter-persistent || true
}

main() {
  assert_root
  check_debian12
  preflight_guard

  install_base_packages
  setup_timezone_ntp
  create_user
  ensure_sudo_ready
  setup_sshd_security
  setup_unattended_upgrades   # keep or comment out per host role
  setup_fail2ban
  sysctl_network_tuning
  set_limits
  set_journal
  firewall_iptables
  reload_services
  print_summary
}

main "$@"
